---
title: "Trabajo Detección de Anomalías"
author: "Antonio David Villegas Yeguas"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Bibliotecas y funciones a utilizar

En esta sección simplemente cargamos los paquetes y funciones que utilizaremos a lo largo del trabajo.

```{r}
source("OutliersLibrerias.R")
source("OutliersFunciones_byCubero.R")
# para leer archivos .mat, formato de nuestro dataset
library(rmatio)
```

# 2. Dataset

Para realizar el trabajo se utilizará el conjunto de datos sobre vinos [wine](http://odds.cs.stonybrook.edu/wine-dataset/). Este conjunto de datos contiene información sobre trece atributos de distintas muestras de vino obtenidas de tres cultivos distintos. Los datos originales estaban pensados para resolver un problema de clasificación, en el que el objetivo era predecir el cultivo al que pertenecía la muestra, sin embargo este conjunto ha sido adaptado por la comunidad de http://odds.cs.stonybrook.edu/ para convertirlo en un conjunto de datos con anomalías, donde se han reducido las observaciones del primer cultivo a diez observaciones, que actuarán como outliers, mientras que las observaciones del segundo y tercer cultivo no se han modificado.

Estos datos se proporcionan en formato MATLAB, por lo que utilizaremos el paquete `rmatio` para leerlos. El fichero dado no contiene la información original sobre el cultivo del que proviene cada observación, contiene una matriz X con los trece atributos del vino, y una columna Y que nos dice si un dato es outlier o no.

```{r}
# Leemos los datos
wine_completo <- read.mat("wine.mat") 
wine <- as.data.frame(wine_completo$X)
wine_outliers <- wine_completo$y

# Asignamos los nombres a las columnas
names(wine) <- c("Alcohol", "Malic_acid", "Ash", "Alcalinity_of_ash", "Magnesium", "Total_phenols", "Flavanoids", "Nonflavanoid_phenols", "Proanthocyanins", "Color_intensity", "Hue", "OD280/OD315_of_diluted_wines", "Proline")

```


Al igual que en el guión de prácticas, utilizaremos distintos objetos auxiliares que nos ayudarán a realizar el trabajo.

- `datos`: Data frame con los datos de wine.
- `datos.num`: Data frame con las columnas de wine que sean de tipo numérico.
- `indice.columna`: Indice de la columna con la que trabajaremos.
- `nombre.columna`: Nombre de la columna con la que trabajaremos.

Además, eliminaremos las filas que contengan valores perdidos y las columnas que sean valores ordinales.


```{r echo = FALSE}
# creamos los conjuntos de datos

datos <- wine

columnas.num <- sapply(c(1:ncol(datos)), function(x) is.numeric(datos[, x]))
cat("Columnas numéricas: ")
columnas.num

datos.num <- datos[, columnas.num]
cat("Seis primeras filas de los datos: ")
head(datos.num)


datos.num <- na.omit(datos.num)
```
Como podemos ver en el resultado, las 13 columnas del conjunto de datos son numéricas, además de no tener ningún valor ordinal o pocos valores distintos, por lo que no eliminaremos ninguna columna.


# 3. DETECCION DE OUTLIERS EN UNA DIMENSION

En este apartado calcularemos los outliers 1-variantes, es decir, con respecto a una única columna.

## 3.1 OUTLIERS IQR

En este apartado se utilizará el método IQR para detección de outliers. Como ya hemos visto en la asignatura, este método solo se debería aplicar a datos que sigan una distribución normal, sin embargo funciona bastante bien siempre que la distribución no sea muy rara.

Lo primero que haremos será ver los histogramas de todas las columnas del conjunto de datos:

```{r results = "hide"}
# mostramos el histograma de todas las columnas
par(mfrow = c(2,3))
sapply(c(1:ncol(datos.num)), function(x) hist(datos.num[,x], main = "", xlab = names(datos.num)[x]) )
par(mfrow = c(1,1))
```

Como vemos, no parece que ninguna columna siga una distribución rara, a excepción de la columna `OD280/OD315_of_diluted_wines`, que parece seguir una bimodal, al tener dos picos claramente diferenciados.

Se ha decidido seleccionar la columna 13, `Proline`, ya que se trata de una columna con una distribución semejante a la normal, aunque podemos ver que tiene valores en la cola derecha, lo que nos puede ayudar a intuir que encontraremos outliers en esta columna. Vamos a comprobarlo con el método IQR.

```{r}
# variables a usar en el apartado

indice.columna = 13
columna <- datos.num[, indice.columna]
nombre.columna <- names(datos.num)[indice.columna]
```

### 3.1.1 Obtencion de outliers IQR

Al igual que en el guión de prácticas, calcularemos los cuartiles de la columna, así como su distancia intercuartil:

```{r}
# Calculo del cuartil primero, tercero e irq
cuartiles <- quantile(columna, probs = c(0.25, 0.75))
cuartil.primero <- cuartiles[1]
cuartil.tercero <- cuartiles[2]

iqr <- IQR(columna)

cuartil.primero
cuartil.tercero
iqr
```

Tras obtener el primer y tercer cuartil pasamos a obtener los extremos que delimitarán si consideramos un valor outlier, así como outlier extremo.

```{r}

# calculo de extremos que delimitan los outliers

extremo.superior.outlier.IQR <- cuartil.tercero + iqr * 1.5
extremo.inferior.outlier.IQR <- cuartil.primero - iqr * 1.5
extremo.superior.outlier.IQR.extremo <- cuartil.tercero + iqr * 3
extremo.inferior.outlier.IQR.extremo <- cuartil.primero - iqr * 3

extremo.superior.outlier.IQR
extremo.inferior.outlier.IQR
extremo.superior.outlier.IQR.extremo
extremo.inferior.outlier.IQR.extremo
```

Una vez conocemos estos extremos, vamos a observar si tenemos outliers IQR en la columna seleccionada, para ello simplemente comprobamos si el valor de cada observación está fuera del rango comprendido entre los extremos inferiores y superiores calculados anteriormente:

```{r}
# Contruimos vectores logicos que nos dicen si cada registro es outlier o no
son.outliers.IQR <- columna < extremo.inferior.outlier.IQR | columna > extremo.superior.outlier.IQR
son.outliers.IQR.extremos <- columna < extremo.inferior.outlier.IQR.extremo | columna > extremo.superior.outlier.IQR.extremo

head(son.outliers.IQR)
sum(son.outliers.IQR)

head(son.outliers.IQR.extremos)
sum(son.outliers.IQR.extremos)
```

Como podemos ver en los resultados, en esta columna tenemos ocho outliers IQR, de los cuales dos de ellos son outliers extremos.


### 3.1.2 Indices y valores de los outliers IQR

Una vez tenemos vectores lógicos que nos indican que valores son outliers IQR, en esta sección obtendremos sus índices y valores.

Para obtener los índices utilizaremos la función `which` ya que nos devolverá el índice del vector lógico cuyo valor sea `TRUE`, y con los índices podremos obtener los valores. Tabmién obtendremos un frame con las filas de los valores que son outliers, de cara a estudiarlos por separado. Aunque en el guión de prácticas se obtenian los nombres de las filas, en este caso esto se ha omitido ya que en este dataset las filas no tienen nombre, por lo que el nombre será el mismo que el indice de la columna.

```{r}
claves.outliers.IQR <- which(son.outliers.IQR)
df.outliers.IQR <- datos.num[claves.outliers.IQR,]
valores.outliers.IQR <- columna[claves.outliers.IQR]

claves.outliers.IQR.extremos <- which(son.outliers.IQR.extremos)
df.outliers.IQR.extremos <- datos.num[claves.outliers.IQR.extremos,]
valores.outliers.IQR.extremos <- columna[claves.outliers.IQR.extremos]

claves.outliers.IQR
df.outliers.IQR
valores.outliers.IQR

claves.outliers.IQR.extremos
df.outliers.IQR.extremos
valores.outliers.IQR.extremos

```

Vemos como todos los indices obtenidos son los de las filas de la uno a la diez (a excepción de la tres y la cinco), por lo que podemos intuir que los resultados son correctos ya que como vimos en la descripción del dataset, los diez primeros valores correspondían a las observaciones del primer cultivo, del que precisamente se habían mantenido diez instancias para que actuaran como outliers.


### 3.1.3 Cómputo de los outliers de IQR con funciones

Otra opción para obtener los outliers IQR habría sido utilizar las funciones dadas, con las que se obtienen los mismos resultados:


```{r echo = FALSE}
son.outliers.IQR     = son_outliers_IQR (datos.num, indice.columna)
head(son.outliers.IQR)

claves.outliers.IQR  = claves_outliers_IQR (datos.num, indice.columna)
claves.outliers.IQR

son.outliers.IQR.extremos    = son_outliers_IQR (datos.num, indice.columna, 3)
head(son.outliers.IQR.extremos)

claves.outliers.IQR.extremos = claves_outliers_IQR (datos.num, indice.columna, 3)
claves.outliers.IQR.extremos

```



### 3.1.4 Desviacion de los outliers con respecto a la media de la columna

Tras obtener los outliers IQR así como sus valores, vamos a calcular la desviación con respecto a la media de la columna. Para este apartado normalizaremos los datos mediante el método z-score, de cara a poder trabajar como si lo hicieramos con una distribución N(0, 1), en la que podemos decir que un valor es algo inusual si no está en el rango [-2, 2], y bastante inusial si no está en el rango [-3, 3].


```{r echo = FALSE}
datos.num.norm = scale(datos.num)
cat("Datos normalizados por z-score:")
head(datos.num.norm)
columna.norm   = datos.num.norm[, indice.columna]
```

Una vez tenemos los datos normalizados, para obtener los valores de los outliers IQR normalizados simplemente consultamos sus valores ya que disponemos de los indices gracias a los apartados anteriores:

```{r}
valores.outliers.IQR.norm <- columna.norm[claves.outliers.IQR]
valores.outliers.IQR.norm
```

Con esto podemos comprobar que efectivamente son valores raros, al estar por encima (o casi por encima) de dos, e incluso los extremos por encima de tres, mientras que antes al obtener un valor de `Proline` de 1270 no sabíamos si era un valor inusual o no.

También podemos ver el valor de las otras columnas para los outliers IQR de la columna `Proline`:

```{r}
datos.num.norm.outliers.IQR <- datos.num.norm[claves.outliers.IQR,]
datos.num.norm.outliers.IQR
```

En este caso no tienen valores inusuales, a excepción de la segunda fila, en la que el valor de `Alcohol` si es un valor algo inusual.



### 3.1.5 Gráfico

En este apartado mostraremos gráficamente los valores obtenidos en los apartados anteriores utilizando las funciones gráficas dadas. En concreto utilizaremos los datos normalizados y los outliers IQR obtenidos:

```{r}
par(mfrow = c(1,1))

plot_2_colores(columna.norm, claves.outliers.IQR, titulo = nombre.columna)
```

Podemos ver claramente como los valores detectados como outliers son valores inusuales para la columna.

También podemos ver los outliers extremos:

```{r}
plot_2_colores(columna.norm, claves.outliers.IQR.extremos, titulo = nombre.columna)
```


# 3.1.6 Diagramas de cajas

También podemos ver gráficamente las observaciones que son outliers con un diagrama de cajas utilizando los datos normalizados:

```{r}

diag_caja_outliers_IQR(datos.num.norm, indice.columna)

```

También podemos utilizar los nombres de las filas, para ver como los dos puntos más alejados de la caja se tratan de los outliers extremos, los indices 9 y 10:

```{r}
diag_caja(datos.num.norm, indice.columna, claves.a.mostrar = claves.outliers.IQR)

```

Además de esto podemos observar el resto de columnas, para observar si también tienen un valor inusual:

```{r}
diag_caja_juntos(datos.num, titulo = "Outliers en alguna columna", claves.a.mostrar = claves.outliers.IQR)
```

Vemos como los outliers obtenidos en la columna `Proline` no presentan valores inusuales en el resto de columnas, a excepción de la fila 2 en la columna `Alcohol`.


## 3.2 Tests de hipotesis (OPCIONAL)

### 3.2.1 Objetivo

En esta sección vamos a determinar si el valor más alejado de la media puede considerarse como outlier. Para esto utilizaremos un test estadistico donde la hipotesis nula será que el valor más alejado de la media no es un outlier.


### 3.2.2 Comprobación de la hipótesis de Normalidad

El test de Grubbs, test que utilizaremos para comprobar si la hipotesis nula se rechaza o no, asume que los datos deben seguir una distribución normal sin tener en cuenta el valor más alejado de la media. Por este motivo, lo primero que haremos será comprobar visualmente si nuestra distribución se asemeja a una normal:

```{r}
ajusteNormal = fitdist(columna , "norm")
denscomp (ajusteNormal,  xlab = nombre.columna)
```

### 3.2.3 Test de Grubbs

Al ver que los datos siguen una distribución relativamente similar a la normal, aplicamos el test de Grubbs:

```{r}
test.de.Grubbs = grubbs.test(columna, two.sided = TRUE)
test.de.Grubbs$p.value
```

El p-value es menor a 0.05, por lo que rechazamos la hipotesis nula, así que podemos considerar que el valor más alejado de la media es un outlier. Obtenemos ese valor con la función `outlier`:

```{r}
valor.outlier = outlier(columna)
valor.outlier
```

Para obtener el índice del outlier utilizaremos el parámetro `logical` de la función `outlier`, combinado con `which` para saber el índice.

```{r}
es.outlier = outlier(columna, logical = TRUE)
clave.outlier = which( es.outlier == TRUE)
clave.outlier
```

Vemos como el índice obtenido se trata del 9, un valor que anteriormente vimos que se trataba de un outlier extremo utilizando el método IQR.

### 3.2.4 Test de Normalidad

Tras obtener el índice del elemento que es un outlier, pasamos a aplicar el test de normalidad de Shapiro-Wilk:

```{r}
datos.sin.outlier = columna[-clave.outlier]
datos.sin.outlier

shapiro.test(datos.sin.outlier)
goodness_fit = gofstat(ajusteNormal)
goodness_fit$adtest
```

En nuestro caso el test de Anderson-Darling no se ha podido aplicar porque hay pocos datos, mientras que en el test de Shapiro-Wilk se rechaza la hipotesis nula, por lo que los datos no siguen una distribución normal. Esto tal vez se deba a que todavía existen valores anómalos, como vimos con el cómputo de outliers IQR, ya que la décima observación también era considerada como un outlier extremo por IQR, y varias filas eran consideradas outliers IQR.

De cara a automatizar este proceso se ha escrito la siguiente función, que como vemos obtiene los mismo resultados que hemos obtenido manualmente:

```{r}
#######################################################################
# Aplica el test de Grubbs sobre la columna ind.col de datos y devuelve una lista con:

# nombre.columna: Nombre de la columna datos[, ind.col]
# clave.mas.alejado.media: Clave del valor O que está más alejado de la media
# valor.mas.alejado.media: Valor de O en datos[, ind.col]
# nombre.mas.alejado.media: Nombre de O en datos
# es.outlier: TRUE/FALSE dependiendo del resultado del test de Grubbs sobre O
# p.value:  p-value calculado por el test de Grubbs
# es.distrib.norm: Resultado de aplicar el test de Normalidad 
#    de Shapiro-Wilks sobre datos[, ind.col]
#    El test de normalidad se aplica sin tener en cuenta el 
#    valor más alejado de la media (el posible outlier O)
#    TRUE si el test no ha podido rechazar
#       -> Sólo podemos concluir que los datos no contradicen una Normal
#    FALSE si el test rechaza 
#       -> Los datos no siguen una Normal

# Requiere el paquete outliers

test_Grubbs <- function(data.frame, indice.columna, alpha = 0.05) {
	resultado <- list()
	resultado$nombre.columna <- names(data.frame)[indice.columna]
	resultado$clave.mas.alejado.media <- which( outlier(data.frame[,indice.columna], logical = TRUE) == TRUE ) 
	resultado$valor.mas.alejado.media <- data.frame[resultado$clave.mas.alejado.media, indice.columna] 
	resultado$nombre.mas.alejado.media <- nombres_filas(data.frame, resultado$clave.mas.alejado.media)
	
	test.de.Grubbs <- grubbs.test(data.frame[, indice.columna], two.sided = TRUE)
	
	resultado$p.value <- test.de.Grubbs$p.value
	resultado$es.outlier <- test.de.Grubbs$p.value <= alpha
	
	
	datos.sin.outlier <- data.frame[-resultado$clave.mas.alejado.media, indice.columna]
	datos.sin.outlier
	
	resultado$p.value.test.normalidad <- shapiro.test(datos.sin.outlier)$p.value
	resultado$es.distrib.norm <- resultado$p.value.test.normalidad > alpha
	
	resultado
}


test.Grubbs.datos.num = test_Grubbs(datos.num, indice.columna)

test.Grubbs.datos.num
```


## 3.3 Trabajando con varias columnas

En esta sección realizaremos el mismo trabajo pero para cada una de las columnas utilizando las distintas funciones creadas así como las dadas.

### 3.3.1 Outliers IQR

Para obtener los outliers IQR en alguna de las columnas, utilizaremos la función `claves_outliers_IQR_en_alguna_columna`:

```{r}
claves.outliers.IQR.en.alguna.columna <- claves_outliers_IQR_en_alguna_columna(datos.num, 1.5)
claves.outliers.IQR.en.alguna.columna
```

Como vemos, existen valores duplicados, por lo que nos quedamos con los únicos y con los que aparecen en más de una columna:

```{r}
claves.outliers.IQR.en.mas.de.una.columna <- unique(
	claves.outliers.IQR.en.alguna.columna[
		duplicated(claves.outliers.IQR.en.alguna.columna)
	]
)

claves.outliers.IQR.en.alguna.columna <- unique(claves.outliers.IQR.en.alguna.columna)

claves.outliers.IQR.en.mas.de.una.columna
claves.outliers.IQR.en.alguna.columna
nombres_filas(datos.num, claves.outliers.IQR.en.mas.de.una.columna)
nombres_filas(datos.num, claves.outliers.IQR.en.alguna.columna)
```

Podemos observar que en esta lista se encuentran los valores obtenidos mientras estudiabamos la última columna, así como muchas otras observaciones. Vamos a consultar los valores que tiene cada observación en las distintas columnas utilizando los datos normalizados para saber rápidamente en que columna tienen un valor inusual.

```{r}
datos.num.norm[claves.outliers.IQR.en.alguna.columna,]
```

De manera más visual también podemos utilizar un diagrama de cajas:

```{r}
diag_caja_juntos(datos.num, titulo = "Outliers en alguna columna", claves.a.mostrar = claves.outliers.IQR.en.alguna.columna)
```

Podemos ver como las principales columnas que están generando estos outliers son la quinta, novena y decimo tercera columnas, así como la tercera, cuarta, septima, decima y decimo primera columna también obtenemos algunos valores inusuales, aunque en menor número de observaciones

### 3.3.2 Tests de Hipótesis (OPCIONAL)

```{r}

sapply(c(1:ncol(datos.num)), function(x) {test_Grubbs(datos.num, x)})
```

```{r}
#
# 4 Outliers Multivariantes
#


#
# 4.1 Métodos estadísticos basados en la distancia de Mahalanobis (OPCIONAL)
#

son.col.normales <- sapply(c(1:ncol(datos.num)), function(x) {
	test_Grubbs(datos.num, x)$es.distrib.norm
})

son.col.normales

datos.num.distrib.norm <- datos.num[,son.col.normales]
datos.num.distrib.norm <- as.data.frame(datos.num.distrib.norm)
head(datos.num.distrib.norm)

# solo tenemos una columna que sigue una normal, no podemos aplicar mvn para 
# aplicar un test de normalidad multivariado
#test.MVN = mvn(datos.num.distrib.norm, mvnTest = "energy")
#test.MVN$multivariateNormality["MVN"]
#test.MVN$multivariateNormality["p value"]
```

```{r}
#
# 4.1.2 Tests de hipótesis para detectar outliers
#

corr.plot(datos.num[,1], datos.num[,2])

set.seed(2)

# de nuevo, datos.num.distrib.norm es solo una columna, necesitamos multiples
#cerioli.test.individual <- cerioli2010.fsrmcd.test(datos.num.distrib.norm, signif.alpha = 0.05)

#claves.test.individual <- which(cerioli.test.individual$outliers == TRUE)
#claves.test.individual

#nombres.test.individual <- nombres_filas(datos.num.distrib.norm, claves.test.individual)
#nombres.test.individual

set.seed(2)

#cerioli.test.interseccion <- cerioli2010.fsrmcd.test(datos.num.distrib.norm, signif.alpha = 1 - (1 - 0.05)^(1/nrow(datos.num.distrib.norm)))

#claves.test.interseccion <- which(cerioli.test.interseccion$outliers == TRUE)
#claves.test.interseccion

#nombres.test.interseccion <- nombres_filas(datos.num.distrib.norm, claves.test.interseccion)
#nombres.test.interseccion

#distancias.cerioli.test.interseccion.ordenado <- sort(cerioli.test.interseccion$mahdist.rw, decreasing = FALSE)
#clave.mayor.dist.Mah <- order(cerioli.test.interseccion$mahdist.rw, decreasing = FALSE)[1]
#clave.mayor.dist.Mah
#plot(distancias.cerioli.test.interseccion.ordenado)
```

```{r}
#
# 4.2 Visualización de datos con un Biplot
#

biplot.outliers.IQR <- biplot_2_colores(datos.num,
										claves.outliers.IQR.en.alguna.columna,
										titulo.grupo.a.mostrar = "Outliers IQR",
										titulo = "Biplot Outliers IQR")
biplot.outliers.IQR
```

```{r}
#
# 4.3 Métodos basados en distancias: LOF
#

num.vecinos.lof = 5
lof.scores <- LOF(datos.num.norm, k = num.vecinos.lof)

lof.scores.ordenados <- sort(lof.scores, decreasing = T) 

plot(lof.scores.ordenados)

num.outliers <- 3
claves.outliers.lof <- sapply(c(1:num.outliers), function(x) which(lof.scores == lof.scores.ordenados[x]))
claves.outliers.lof

nombres.outliers.lof <- nombres_filas(datos.num, claves.outliers.lof)
nombres.outliers.lof

datos.num.norm[claves.outliers.lof,]


clave.max.outlier.lof <- claves.outliers.lof[1]

colores <- rep("black", times = nrow(datos.num.norm))
colores[clave.max.outlier.lof] <- "red"
pairs(datos.num.norm, pch = 19, cex = 0.5, col = colores, lower.panel = NULL)


biplot.max.outlier.lof <- biplot_2_colores(datos.num.norm, clave.max.outlier.lof, titulo = "Mayor outlier LOF")
biplot.max.outlier.lof


```

```{r}
#
# 4.4 Métodos basados en Clustering
#

num.outliers <- 5
num.clusters <- 3
set.seed(2)
modelo.kmeans <- kmeans(datos.num.norm, num.clusters)

asignaciones.clustering.kmeans <- modelo.kmeans$cluster
centroides.normalizados <- modelo.kmeans$centers


head(asignaciones.clustering.kmeans)
centroides.normalizados


centroides.desnormalizados <- desnormaliza(datos.num, centroides.normalizados)
centroides.desnormalizados



top.outliers.kmeans <- top_clustering_outliers(datos.num.norm,
											   asignaciones.clustering.kmeans,
											   centroides.normalizados,
											   num.outliers)

claves.outliers.kmeans <- top.outliers.kmeans$claves
nombres.outliers.kmeans <- nombres_filas(datos.num, claves.outliers.kmeans)
distancias.outliers.centroides <- top.outliers.kmeans$distancias

claves.outliers.kmeans

nombres.outliers.kmeans

distancias.outliers.centroides


biplot_outliers_clustering(datos.num,
						   titulo = "Outliers k-means",
						   asignaciones.clustering = asignaciones.clustering.kmeans,
						   claves.outliers = claves.outliers.kmeans)


diag_caja_juntos(datos.num, "Outliers k-means", claves.outliers.kmeans)

```

```{r}
#
# 4.4.2 Clustering usando medoides (OPCIONAL)
#


```

```{r}
#
# 4.5 Análisis de los outliers multivariantes puros
#

claves.outliers.lof.no.IQR <- setdiff(claves.outliers.lof, claves.outliers.IQR.en.alguna.columna)
nombres.outliers.lof.no.IQR <- nombres_filas(datos.num, claves.outliers.lof.no.IQR)

claves.outliers.IQR.en.alguna.columna
claves.outliers.lof

claves.outliers.lof.no.IQR
nombres.outliers.lof.no.IQR

num.outliers <- 11
claves.outliers.lof <- sapply(c(1:num.outliers), function(x) which(lof.scores == lof.scores.ordenados[x]))
claves.outliers.lof

nombres.outliers.lof <- nombres_filas(datos.num, claves.outliers.lof)
nombres.outliers.lof

claves.outliers.lof.no.IQR <- setdiff(claves.outliers.lof, claves.outliers.IQR.en.alguna.columna)
nombres.outliers.lof.no.IQR <- nombres_filas(datos.num, claves.outliers.lof.no.IQR)


claves.outliers.IQR.en.alguna.columna
claves.outliers.lof

claves.outliers.lof.no.IQR
nombres.outliers.lof.no.IQR


biplot.outliers.puros <- biplot_2_colores(datos.num.norm, 
										 claves.outliers.lof.no.IQR, 
										 titulo = "Outliers LOF (excluidos los que son IQR)")

biplot.outliers.puros


datos.num.norm[claves.outliers.lof.no.IQR, ]
```




















